<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <title>Audio Spectrum Analyzer</title>


    <style>
        body{
            background-color: black;
            color: rgb(200, 200, 200);
        }

        .container{
            width: 100%;
            flex-direction: row;
            justify-items: center;
            text-align: center;
        }

        .content{
            display: flex;
            flex-direction: row;
            margin-top: 100px;
            overflow: auto;
        }
        
        .label{
            text-align: center;
        }
    </style>
    
</head>
<body>
    <div class="container">
        <h1>Audio Spectrum Analyzer</h1>
        <div>nejimon.raveendran</div>
        <div id="msg"></div>
        
        <div class="content">
            <!--  -->
        </div>        
    </div>
    
    <script>
        let _socketServer = "ws://mypi5.local:8080/ws";
        let _webDisplay;
        let _socketClient;

        $(document).ready(() => {
            _socketClient = new SocketClient(_socketServer, onSocketConnect, onSocketDisConnect, onSocketMessage);            
            _socketClient.connect();

            window.setInterval(() => {
                let readyState = _socketClient.getStatus();
                switch (readyState) {
                    case 0: //connecting
                        $('#msg').html("Attempting to connect to Spectrum Server...");
                        $('#msg').css('color', 'yellow');                
                        break;
                    case 3: //closed
                        _socketClient.connect();
                        break;
                    default:
                        break;
                }
                
            }, 3000); 

        });

        let onSocketConnect = () =>{
            console.log("WebSocket connected!");
            $('#msg').html("Connected to Spectrum Server");
            $('#msg').css('color', 'greenyellow');
        };

        let onSocketDisConnect = () =>{
            console.log("WebSocket disconnected!");
            $('#msg').html("Disconnected from Spectrum Server");
            $('#msg').css('color', 'red');

            if(_webDisplay === null || _webDisplay === undefined) return;
            _webDisplay.clear();    
        };


        let onSocketMessage = (data) => {
            if(data.Event == "startup"){
                _webDisplay = new WebDisplay(data.Data.Rows, data.Data.Cols);
            }else if (data.Event == "display"){
                _webDisplay.displayLevels(data.Data);
            }
        };



        class SocketClient{
            constructor(url, onConnect, onDisconnect, onMessage){
                this._socket = null;
                this._url = url;
                this._onConnect = onConnect;
                this._onDisconnect = onDisconnect;
                this._onMessage = onMessage;
            }

            connect(){
                this._socket = new WebSocket(this._url);
                this._socket.onopen = this.onSocketConnect.bind(this);
                this._socket.onclose = this.onSocketDisConnect.bind(this);
                this._socket.onmessage = this.onSocketMessage.bind(this);
            }

            onSocketConnect(){
                this._onConnect();
            }

            onSocketDisConnect(callback){
                this._onDisconnect();
            }

            onSocketMessage(event){
                if(event.data === null || event.data === undefined || event.data == '') return;
                let data = JSON.parse(event.data);
                this._onMessage(data);
        
            }

            getStatus(){
                if(this._socket === null || this._socket === undefined) return -1; //-1 = unknown
                return this._socket.readyState; //0 = connecting, 1 = connected, 2 = closing, 3 = closed,
            }

        }


        class WebDisplay{
            constructor(rows, cols){
                this._winWid = window.innerWidth;
                this._winHgt = window.innerHeight;
                this._rows = rows;
                this._cols = cols;  
                this._pixelColors = [,];
                this._curLevels = [this._cols];
                this._colPeaks = [this._cols];
                this._peakColor = 'red';
                this._blackPixel = 'black';
                this._colPeaks = [];
                this._transitionSpeed = 2;
                this._peakWait = 500;
                this._peakWaitCountDown = 20;
                this._showPeaks = true;
                this._pixelWid = this._winWid / (this._cols * 2);
                this._pixelHgt =  (1 / this._rows) * 250;

                for (let i = 0; i < this._cols; i++) {
                    this._curLevels.push(0);
                    this._colPeaks.push({ col: i, row: 0, curWait: 0, curTime: 0, prevTime: 0  });
                }

                this.buildMatrix();
                this.setupDefaultColors();
            }

            clear(){
                let allPixels = $(`#tblMatrix tr td`); 
                if(allPixels === null || allPixels === undefined) return;
                allPixels.css('backgroundColor', this._blackPixel);
            }

            displayLevels(targetLevels){
                for (let x = 0; x < this._cols; x++) {
                    if(targetLevels[x].Level > this._curLevels[x])
                    {
                        this._curLevels[x] = targetLevels[x].Level;                    
                    }else if (targetLevels[x].Level < this._curLevels[x]){
                        this._curLevels[x] = Math.max(this._curLevels[x] - this._transitionSpeed, targetLevels[x].Level);  //bring down gradually
                    }
                    
                    for (let y = 0; y < this._rows; y++)
                    {
                        let color = '';                                            
                        if(y < this._curLevels[x] ){
                            color =  this._pixelColors[x, y]; 
                        }else{
                            color = this._blackPixel;                        
                        }     
                        
                        let colPixel = $(`#tblMatrix tr td[data-px-x="${x}"][data-px-y="${y}"]`); 
                        colPixel.css('backgroundColor', color);
                    }

                    let bandInfo = $(`#tblMatrix tr td[data-band-x="${x}"]`);
                    bandInfo.html(targetLevels[x].Band >= 1000 ? (targetLevels[x].Band/1000) + 'KHz' :  targetLevels[x].Band + 'Hz' );


                    if(this._showPeaks){
                        this.setPeaks(x, this._curLevels[x]);
                    }

                }    
            }

            setPeaks(col, value){
                let topRowIndex = this._rows - 1;

                if(value > this._colPeaks[col].row)  //set new peaks if current value is greater than previously stored peak.
                {
                    this._colPeaks[col].row = value; //set peak at one above the actual value.

                    if(this._colPeaks[col].row > topRowIndex)  //dont let it overflow the top row index
                    { 
                        this._colPeaks[col].row = topRowIndex;
                    }

                    this._colPeaks[col].curTime = this._colPeaks[col].prevTime = Date.now();
                    this._colPeaks[col].curWait = this._peakWait;

                }

                //set peaks
                let color = '';       
                if(this._colPeaks[col].row >= 0) //if value (x) not at bottom, set peak color of the row
                {
                    color = this._peakColor;
                }
                else //otherwise set to black. 
                { 
                    color = this._blackPixel;
                }

                let colPixel = $(`#tblMatrix tr td[data-px-x="${col}"][data-px-y="${this._colPeaks[col].row}"]`); 
                colPixel.css('backgroundColor', color);


                //logic for the peaks to fall down
                this._colPeaks[col].curTime = Date.now();

                if (this._colPeaks[col].curTime - this._colPeaks[col].prevTime >= this._colPeaks[col].curWait)
                {
                    if(this._colPeaks[col].row > 0)
                    {
                        this._colPeaks[col].row -= 1; //deduct one row (creates fall down effect)
                        this._colPeaks[col].prevTime = this._colPeaks[col].curTime;

                    }

                }

                this._colPeaks[col].curWait -=  this._peakWaitCountDown;


                if(this._colPeaks[col].curWait < this._peakWaitCountDown)
                {
                    this._colPeaks[col].curWait = this._peakWaitCountDown;
                    
                }

            }

            
            buildMatrix(){
                let matrixHtml = '';
                
                matrixHtml += '<table id="tblMatrix">';

                for (let y = this._rows-1; y >= 0; y--) {  
                    let hue = this.map(y, 0, this._rows, 100, 0);
                    let color =  `hsl(${hue}, 100%, 50%)`;  
                    matrixHtml += '<tr>';
                    for (let x = 0; x < this._cols; x++) {
                        this._pixelColors[x, y] = color;

                        matrixHtml += `<td data-px-x="${x}" data-px-y="${y}"  
                        style="min-width:${this._pixelWid}px; 
                        min-height:${this._pixelHgt}px; 
                        width: ${this._pixelWid}px;
                        height: ${this._pixelHgt}px;
                        border-right: ${10}px; 
                        border-style: solid;
                        border-color: rgb(10, 10, 10);
                        background-color: ${this._pixelColors[x, y]};
                        background-color: rgb(5, 5, 5);
                        "></td>`;
                    }

                    matrixHtml += '</tr>';
                }

                //display bands
                matrixHtml += '<tr>';
                for (let x = 0; x < this._cols; x++) {
                    matrixHtml += `<td data-band-x="${x}">${x}</td>`;
                }
                matrixHtml += '</tr>';

                matrixHtml += '</table>';

                $('.content').html(matrixHtml);
            }

            setupDefaultColors()
            {
                for (let x = 0; x < this._cols; x++)
                {
                    for (let y = 0; y < this._rows; y++)
                    {
                        let hueIndex = this.map(y, 0, this._rows-1, 100, 0); //map row numbers to the color range green to red
                        this._pixelColors[x, y] =  `hsl(${hueIndex}, 100%, 50%)`;
                    }            
                }
            }

            map(value, fromMin, fromMax, toMin, toMax){
                return toMin + (value - fromMin) * (toMax - toMin) / (fromMax - fromMin);
             }

        }

    </script>
    
</body>
</html>